#include <iostream>
#include <thread>
#include <mutex>
#include <fstream>
#include <string>
#include <cstdint>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <iterator> 

using namespace std;

//Given the number of pieces, read the file with the puzzles. Return number of puzzles read.
int GetPuzzles(int n_pieces, string puzzles[1000]){
    int i = 0;
    string s = "puzzles/3x3_" + to_string(n_pieces) + ".txt";
    ifstream f(s.c_str());
    
    while(!f.eof()){
        getline(f, puzzles[i]);
        i++;
    }
    
    f.close();
    return i;
}

//Create the puzzle grid
void CreateGrid(int height, int width, int n_pieces, string puzzle, char grid[10][10]){
    int piece_i, piece_j;
    char type;
    
    //create blank pieces board
    for(int i = 0; i < height - 1; i++){
        for(int j = 0; j < width - 1; j++)
            grid[i][j] = '-';
    }

    //put the pieces on board
    for(int k = 0; k < n_pieces; k++){
        sscanf(puzzle.c_str(), "%d %d %c", &piece_i, &piece_j, &type);
        grid[piece_i][piece_j] = type;
        
        if(6 <= puzzle.size())
            puzzle = puzzle.substr(6, puzzle.size());
    }
}

//Create input for the solver
void CreateInputSolver(int puzzle_id, int height, int width, int n_pieces, string puzzle, char grid[10][10]){
    int piece_i, piece_j;
    char type;
    string s = "temp/input_" + to_string(puzzle_id) + ".txt";
    ofstream f(s.c_str());
    
    CreateGrid(height, width, n_pieces, puzzle, grid);
    
    f << height << " " << width << endl;
    f << height - 1 << " 0\n";
    f << "0 " << width - 1 << endl;
      
    //output grid
    for(int i = 0; i < height - 1; i++){
        for(int j = 0; j < width - 1; j++)
            f << grid[i][j] << " ";
        f << endl;
    }
}

//Get the solutions from the solver
int GetSolutionsFromSolver(int puzzle_id, string solutions[1000]){
    string s = "solutions/solution_" + to_string(puzzle_id) + ".txt";
    ifstream f(s.c_str());
    int n_solutions = 0;
    
    //read the lines
    while(!f.eof()){
        getline(f, solutions[n_solutions]);
        n_solutions++;
    }
    n_solutions--;
    f.close();
    
    return n_solutions;
}

//Create input for the path_generator
void CreateInputGenerator(int puzzle_id, int n_pieces, int height, int width, int n_solutions, string solutions[1000], int mode){
    string s = "temp/input_" + to_string(puzzle_id) + ".txt";
    ofstream f(s.c_str());
    
    f << height << " " << width << endl;
    f << n_pieces << endl;
    f << height - 1 << " 0\n";
    f << "0 " << width - 1 << endl;
    f << n_solutions << endl;
    
    if(mode == 0)
        f << "5" << endl;
    else
        f << "1" << endl;
    
    //print the solutions
    for(int i = 0; i < n_solutions; i++)
        f << solutions[i] << endl;
    
    f.close();
}

//Check if a file is empty
bool emptyFile(ifstream& f)
{
    return f.peek() == ifstream::traits_type::eof();
}

//Select a random puzzle from the ones generated by path_generator
bool SelectGeneratedPuzzle(int puzzle_id, int height, int width, int n_pieces, char grid[10][10], int n_solutions[3], string solutions[3][1000]){
    string s = "generated_puzzles/generated_" + to_string(puzzle_id) + ".txt";
    ifstream f(s.c_str());
    string line;
    int r;
    int n_puzzles = 0;
    int piece_i, piece_j;
    char type;
    
    if(emptyFile(f))
        return false;
        
    //count number of lines
    while(!f.eof()){
        getline(f, line);
        getline(f, line);
        n_puzzles++;
    }
    n_puzzles--;
    
    //back to start
    f.clear();
    f.seekg(0, ios::beg);
    
    //select a random puzzle
    r = rand() % n_puzzles;
    
    //go to that puzzle on the file
    for(int i = 0; i < r; i++){
        getline(f, line);
        getline(f, line);
    }
    
    //create grid for the puzzle
    getline(f, line);
    CreateGrid(height, width, n_pieces, line, grid);
    
    //get the solutions
    int sol;
    int i = 0;
    string delimiter = " ";
    size_t pos = 0;
    string token;
    
    getline(f, line);
    while ((pos = line.find(delimiter)) != string::npos) {
        token = line.substr(0, pos);
        sol = stoi(token, NULL, 10);
        solutions[puzzle_id][i] = solutions[puzzle_id - 1][sol];
        i++;
        line.erase(0, pos + delimiter.length());
    }
    n_solutions[puzzle_id] = i;
    
    return true;
}

//check if 2 puzzles have at least 5 solutions in common
bool CheckSolutions(int puzzle_id1, int puzzle_id2){
    string solutions[2][1000];
    int n_solutions[2];
    int common = 0;
    
    //get solutions
    n_solutions[0] = GetSolutionsFromSolver(puzzle_id1, solutions[0]);
    n_solutions[1] = GetSolutionsFromSolver(puzzle_id1, solutions[0]);
    
    //compare them
    for(int i = 0; i < n_solutions[0]; i++){
        for(int j = 0; j < n_solutions[1]; j++){
            if(solutions[0][i].compare(solutions[1][j]) == 0)
                common++;
            
            if(common == 5)
                return true;
        }
    }
    
    return false;
}

int main(){
    int n_pieces[3];
    int n_puzzles[3];
    string puzzles[1000];
    char grid[3][10][10];
    string solutions[3][1000];
    int n_solutions[3];
    
    srand(time(NULL));

    //loop that will run until a puzzle that meet the conditions is discovered
    while(true){
        //delete previous files
        remove("solutions/solution_0.txt");
        remove("solutions/solution_1.txt");
        remove("solutions/solution_2.txt");
        
        remove("temp/input_0.txt");
        remove("temp/input_1.txt");
        remove("temp/input_2.txt");
        
        remove("generated_puzzles/generated_0.txt");
        remove("generated_puzzles/generated_1.txt");
        remove("generated_puzzles/generated_2.txt");
        
        //generates number of pieces per puzzle
        for(int i = 0; i < 3; i++)
            n_pieces[i] = rand() % 3 + 1;
        
        //read the puzzles
        for(int i = 0; i < 3; i++)
            n_puzzles[i] = GetPuzzles(n_pieces[i], puzzles);
        
        //select randomly the first puzzle
        int p;
        p = rand() % n_puzzles[0];
        
        //create input file for the first puzzle
        CreateInputSolver(0, 4, 4, n_pieces[0], puzzles[p], grid[0]);
        
        //call solver so that it generate all solutions for first puzzle
        cout << "SOLVING 1ST PUZZLE...\n";
        system("./solver/solver 0 < temp/input_0.txt");
        cout << "FINISHED SOLVING!\n";
        
        //read the solutions from the solver
        n_solutions[0] = GetSolutionsFromSolver(0, solutions[0]);
        
        //create input for path_generator
        CreateInputGenerator(1, n_pieces[1], 4, 4, n_solutions[0], solutions[0], 0);
        
        //call path_generator
        cout << "GENERATING 2ND PUZZLE...\n";
        system("./path_generator/generator 1 0 < temp/input_1.txt");
        cout << "FINISHED GENERATING!\n";
    
        //select a random puzzle
        SelectGeneratedPuzzle(1, 4, 4, n_pieces[1], grid[1], n_solutions, solutions);
        
        //create input for path_generator
        CreateInputGenerator(2, n_pieces[2], 4, 4, n_solutions[1], solutions[1], 1);
        
        //call path_generator
        cout << "GENERATING 3RD PUZZLE...\n";
        system("./path_generator/generator 2 1 < temp/input_2.txt");
        cout << "FINISHED GENERATING!\n";
        
        //select a random puzzle
        if(SelectGeneratedPuzzle(2, 4, 4, n_pieces[2], grid[2], n_solutions, solutions)){
            /*//solve third puzzle
            CreateInputSolver(2, 4, 4, n_pieces[2], puzzles[p], grid[2]);

            cout << "SOLVING 3RD PUZZLE...\n";
            system("./solver/solver 2 < temp/input_2.txt");
            cout << "FINISHED SOLVING!\n";
            
            if(CheckSolutions(0, 2) && CheckSolutions(1, 2))*/
                break;
        }
    }
    
    //now we got the 3 puzzles, print them
    for(int k = 0; k < 3; k++){
        cout << "PUZZLE " << k + 1 << endl;
        
        for(int i = 0; i < 3; i++){
            for(int j = 0; j < 3; j++)
                cout << grid[k][i][j] << " ";
            cout << endl;
        }
    }
    
    return 0;
}
